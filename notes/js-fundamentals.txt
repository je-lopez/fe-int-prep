Scope & Closures
  - scope refers to where variables and functions are accessible, and in what context it's being executed
    - functions and variables have so called function scope, and can be declared at a global or local context
  - a closure is the combination of a function and the lexical environment (surrounding state) within which that function was declared
    - a closure gives you access to an outer function's scope from an inner function
    - in JS, a closure is created every time a function is created, at function creation time
    - useful because they let you associate data with a function that operates on that data
    - useful for emulating private methods. (see below for example)

2. JS Module Pattern (good for performance)
  - closures follow this pattern
  - anonymous closures - the fundamental construct that makes it possible
  - IIFE (immediately invoked function expression) is an anonymous function that's executed immediately. the code lives in a closure

  Extensible contructs:
  - augmentation - first, we import the module, then we add properties, then we export it
    var MODULE = (function(my) {
      my.anotherMethod = function() {
        // added method
      }

      return my;
    }(MODULE));

  - loose augmentation: when we create flexible multi-part modules that can load themselves in any order
    - limitation: you can't override module properties safely. also can't use module properties from other files during initialization
      var MODULE = (function(my) {
        // add capabilities

        return my;
      }(MODULE || {}));

  - tight augmentation: implies a set loading order, but allows overrides. here's a simple augmentation:
      var MODULE = (function (my) {
        var old_moduleMethod = my.moduleMethod;

        my.moduleMethod = function () {
          // method override, has access to old through old_moduleMethod...
        };

        return my;
      }(MODULE));

  - cloning and inheritance
    - the least flexible, but does allow some neat compositions (example exluded)
  - cross-file private state
    - a severe limitation is that each file maintains its own private state with no access to other private state
    - ^this can be fixed by setting properties on their local variable _private, which will be immediately available to the others
      var MODULE = (function(my) {
        var _private = my._private = my._private || {},
            _seal = my._seal = my._seal || function () {
              delete my._private;
              delete my._seal,
              delete my._unseal,
            },
            _unseal = my._unseal = my._unseal || function () {
              my._private = _private;
              my.seal = seal;
              my.unseal = unseal;
            };
        // permanent access to _private, _seal, and _unseal

        return my;
      }(MODULE || {}));

  - submodules - the simplest, and is like creating regular modules:
      MODULE.sub = (function () {
        var my = {};
        // ...

        return my;
      }());

  - emulate private method w/closure example:
    - the shared lexical environment is created in the body of an anonymous function, which is executed as soon at it has been defined, aka IIFE

      var counter = (function() {
        var privateCounter = 0;
        function changeBy(val) {
          privateCounter += val;
        }

        return {
          increment: function() {
            changeBy(1);
          },

          decrement: function() {
            changeBy(-1);
          },

          value: function() {
            return privateCounter;
          }
        };
      })();

3. Inheritance

4. Promises

5. HTTP
